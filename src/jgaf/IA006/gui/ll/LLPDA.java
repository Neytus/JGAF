/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package jgaf.IA006.gui.ll;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.EmptyStackException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import jgaf.IA006.tools.Tools;
import jgaf.IA006.grammar.LLEpsilon;
import jgaf.IA006.grammar.LLGrammar;
import jgaf.IA006.grammar.LLSymbol;

/**
 *
 * @author Empt
 */
public class LLPDA 
{
    private Stack<LLSymbol> stack = new Stack<>();
    private List<LLSymbol> inputWord = new ArrayList<>();
    private LLTable table;    
    private StringBuilder sb;
    private StackTableModel stm;
    
    public LLPDA(LLTable table, LLGrammar g, StringBuilder sb, StackTableModel stm)
    {
        this.stm = stm;
        this.table = table;
        this.sb = sb;
        Set<List<LLSymbol>> temp = new HashSet<>();
        LLSymbol eps = new LLEpsilon();
        temp.add(Arrays.asList(eps));
        LLSymbol s = new TSymbol(0, g.getRootSymbol(), temp);
        stack.push(s);
        stm.setup(stack);
        sb.append("<table>");
    }

    public List<LLSymbol> getInputWord() {
        return inputWord;
    }
    
    public void setWord(List<LLSymbol> inputWord)
    {
        this.inputWord = inputWord;
    }
    
    /**
     * Method makes fake step so output window will be refreshed
     */
    public void doFakeStep()
    {
        sb.append("<tr><td>(</td><td>q ,</td><td>&#949;</td><td>,</td><td>&#949;</td><td>)</td><td>&#09;ACCEPT</td></tr>");
    }
    
    /**
     * Method used as simple step between computations
     */
    public void doStep()
    {
        LLSymbol top = null;
        try
        {   // popnem symbol
            top = stack.pop();
        }
        catch(EmptyStackException ese)
        {   //toto je ochrana pre gramatiku s pravidlom
            // S-> \eps
            LLSymbol eps = new LLEpsilon();
            if(inputWord.equals(Arrays.asList(eps)))
            {
                inputWord = new ArrayList<>();
                throw ese;
            }
            else
            {
                throw ese;
            }
        }
        if(top != null)
        {
            //overim zhodu [a,a] kde a \in \Sigma
            if(top.isTerminal() && inputWord.get(0).equals(top))
            {   //je to neterminal a zhoda sedi tak orezem vstup
                buildOutputRow(top, inputWord.subList(0,1),null, true);
                inputWord = inputWord.subList(1, inputWord.size());   
                stm.step();
            }
            else if(top.isNonterminal())
            {   // je to neterminal takze si oznacim ci nastane match
                boolean hasSwitched = false;
                for(List<LLSymbol> prefix : table.colsAsList())
                {   // beham cez stlpce ale len tie co vyhovuju dlzke
                    // pretoze ak by slovo bolo aa, a ja sa spytam na prefix bbc
                    // tak to crashne na indexExcpetion. ak sedi prefix tak cekujem ci su rovnake symboly
                    if(inputWord.size() >= prefix.size() && prefix.equals(inputWord.subList(0, prefix.size())))
                    {
                        if(table.getValueAtPosition(top, prefix) != null)
                        {   // je to ok takze vezmem pravu stranu pravidla do pomocneho zasobnika
                            TState ts = table.getValueAtPosition(top, prefix);
                            List<LLSymbol> toStack = new ArrayList<>(ts.getRule());
                            buildOutputRow(top, null, ts,false);
                            if(toStack.size() == 1 && toStack.get(0).isEpsilon())
                            {
                                // epsilon nic nerobi iba maze symbol
                            }
                            else
                            {   // otocim co tlacim na zasobnik
                                for(int i = toStack.size()-1; i >= 0 ; i--)
                                {
                                    stack.push(toStack.get(i));
                                }
                            }
                            //oznacim si zmenu a z dovodu efektivity vyskocim z foru
                            hasSwitched = true;
                            break; 
                        }
                        else
                        {
                            throw new IllegalArgumentException("ERROR: For given prefix ["+Tools.buildWord(prefix)+"] is no rule. Word cannot be generated by given gramar."); // chybna kombinacia
                        }
                    }                    
                }
                // notifikujem table model o zmene obsahu zasobnika
                stm.step();
                if(!hasSwitched)
                {   // sem by sa to dostat nemalo pretoze ak je zhodny
                    // prefix a zasobnik tak to crashne cez IAE error
                    throw new IllegalArgumentException("There has been error for unprocessed input.\nFor given combination there is no computation.\nIt means that given word cannot be generated by selected grammar.");
                }
            }
        }
    }
    
    /**
     * Method used as complete computation upon setted word.
     */
    public void run()
    {
        while(!stack.isEmpty())
        {            
            doStep();
        }
        if(inputWord.isEmpty())
        {
            doFakeStep();
        }       
    }
    
    /**
     * Metoda buduje tabulku do gui
     * @param top popnuty symbol
     * @param rule pravidlo
     * @param ts stav
     * @param simple pravidlo vs single pop
     */
    private void buildOutputRow(LLSymbol top,List<LLSymbol> rule, TState ts,boolean simple)
    {
        sb.append("<tr><td>(</td><td>q ,</td><td>").append(Tools.buildWord(inputWord)).append("</td><td>,</td><td>")
                .append(top).append(Tools.buildWordReversed(stack)).append("</td><td>)</td><td>");

        if(simple)
        {
            sb.append("&#187 ").append(Tools.buildWord(rule));
        }
        else
        {
            sb.append("&#09;").append(ts.getLeftSide()).append("&#8594;").append(Tools.buildWord(ts.getOriginalRule())).append("</td></tr>");
        }
    }    
}
